package ui

import (
	"fmt"
	"os"
	"path/filepath"

	"lazyproxyflare/internal/config"
)

// WizardStep represents a step in the setup wizard
type WizardStep int

const (
	WizardStepWelcome WizardStep = iota
	WizardStepBasicInfo   // Profile name + Domain
	WizardStepCloudflare  // API Token + Zone ID
	WizardStepDockerConfig // Docker method, compose path, container, caddyfile paths
	WizardStepSummary
)

// WizardField tracks which field is focused within a multi-field step
type WizardField int

// Fields for WizardStepBasicInfo
const (
	FieldProfileName WizardField = iota
	FieldDomain
)

// Fields for WizardStepCloudflare
const (
	FieldAPIToken WizardField = iota
	FieldZoneID
)

// Fields for WizardStepCaddyConfig (Step 3: Caddy Configuration)
const (
	FieldDeploymentMethod WizardField = iota // Docker Compose, Plain Docker, or System
	FieldComposeFilePath                     // Only for Docker Compose
	FieldContainerName                       // Only for Docker
	FieldCaddyfilePath                       // Always required
	FieldCaddyfileContainerPath              // Only for Docker
	FieldCaddyBinaryPath                     // Only for System (auto-detected)
)

// WizardData holds all data collected during wizard
type WizardData struct {
	// Profile metadata
	ProfileName string

	// Cloudflare
	Domain   string
	APIToken string
	ZoneID   string

	// Proxy configuration
	ProxyType        config.ProxyType
	DeploymentMethod config.DeploymentMethod // "docker" or "system"
	DockerMethod     string                  // "compose" or "plain" (only for docker)
	ComposeFilePath  string                  // Path to docker-compose.yml (for compose method)

	// Caddy-specific
	CaddyfilePath          string // Host path (for reading/writing)
	CaddyfileContainerPath string // Path inside Docker container (for validation, docker only)
	ContainerName          string // Docker container name (docker only)
	CaddyBinaryPath        string // Path to caddy binary (system only, auto-detected)
	ValidationCommand      string

	// Defaults
	DefaultCNAMETarget     string
	DefaultProxied         bool
	DefaultPort            int
	DefaultSSL             bool
	DefaultLANSubnet       string
	DefaultAllowedExternal string

	// Form navigation within steps
	CurrentField WizardField
}

// ToProfileConfig converts wizard data to ProfileConfig
func (w *WizardData) ToProfileConfig() (*config.ProfileConfig, error) {
	// Create cloudflare config with plaintext token
	cfConfig := config.CloudflareConfig{
		APIToken: w.APIToken,
		ZoneID:   w.ZoneID,
	}

	profile := &config.ProfileConfig{
		Profile: config.ProfileMetadata{
			Name: w.ProfileName,
		},
		Cloudflare: cfConfig,
		Domain:     w.Domain,
		Proxy: config.ProxyConfig{
			Type:       w.ProxyType,
			Deployment: w.DeploymentMethod,
		},
		Defaults: config.DefaultsConfig{
			CNAMETarget:       w.DefaultCNAMETarget,
			Proxied:           w.DefaultProxied,
			Port:              w.DefaultPort,
			SSL:               w.DefaultSSL,
			LANSubnet:         w.DefaultLANSubnet,
			AllowedExternalIP: w.DefaultAllowedExternal,
		},
		UI: config.UIConfig{
			Theme: "auto",
		},
	}

	// Add Caddy-specific configuration
	if w.ProxyType == config.ProxyTypeCaddy {
		caddyConfig := config.CaddyProxyConfig{
			CaddyfilePath: w.CaddyfilePath,
		}

		if w.DeploymentMethod == config.DeploymentDocker {
			// Docker deployment
			caddyConfig.CaddyfileContainerPath = w.CaddyfileContainerPath
			caddyConfig.ContainerName = w.ContainerName
			caddyConfig.DockerMethod = w.DockerMethod
			caddyConfig.ComposeFilePath = w.ComposeFilePath
		} else {
			// System deployment
			caddyConfig.CaddyBinaryPath = w.CaddyBinaryPath
		}

		// ValidationCommand is auto-generated by GetValidationCommand()
		profile.Proxy.Caddy = caddyConfig
	}

	return profile, nil
}

// DeploymentOptions returns available deployment options for wizard
func DeploymentOptions() []SelectOption {
	return []SelectOption{
		{Label: "Docker Compose", Value: "compose", Enabled: true},
		{Label: "Plain Docker (Portainer, docker run)", Value: "plain", Enabled: true},
		{Label: "System (systemd, snap, binary)", Value: "system", Enabled: true},
	}
}

// DockerMethodOptions returns available Docker method options for wizard
// Deprecated: Use DeploymentOptions instead
func DockerMethodOptions() []SelectOption {
	return DeploymentOptions()
}

// SelectOption represents a selectable option in wizard
type SelectOption struct {
	Label   string
	Value   string
	Enabled bool
}

// GetNextStep returns the next wizard step based on current step
func GetNextStep(current WizardStep, data *WizardData) WizardStep {
	switch current {
	case WizardStepWelcome:
		return WizardStepBasicInfo
	case WizardStepBasicInfo:
		return WizardStepCloudflare
	case WizardStepCloudflare:
		return WizardStepDockerConfig
	case WizardStepDockerConfig:
		return WizardStepSummary
	case WizardStepSummary:
		return WizardStepSummary // Stay on summary
	default:
		return current
	}
}

// GetPreviousStep returns the previous wizard step
func GetPreviousStep(current WizardStep, data *WizardData) WizardStep {
	switch current {
	case WizardStepWelcome:
		return WizardStepWelcome
	case WizardStepBasicInfo:
		return WizardStepWelcome
	case WizardStepCloudflare:
		return WizardStepBasicInfo
	case WizardStepDockerConfig:
		return WizardStepCloudflare
	case WizardStepSummary:
		return WizardStepDockerConfig
	default:
		return current
	}
}

// GetFieldCount returns the number of fields in a step
func GetFieldCount(step WizardStep, data *WizardData) int {
	switch step {
	case WizardStepBasicInfo:
		return 2 // ProfileName, Domain
	case WizardStepCloudflare:
		return 2 // APIToken, ZoneID
	case WizardStepDockerConfig:
		if data.DeploymentMethod == config.DeploymentSystem {
			// System: DeploymentMethod, CaddyfilePath, CaddyBinaryPath
			return 3
		}
		// Docker: DeploymentMethod, ContainerName, CaddyfilePath, CaddyfileContainerPath
		// + ComposeFilePath if compose method
		if data.DockerMethod == "compose" {
			return 5
		}
		return 4
	default:
		return 0
	}
}

// ValidateCurrentStep validates data for current wizard step
func ValidateCurrentStep(step WizardStep, data *WizardData) error {
	switch step {
	case WizardStepBasicInfo:
		if data.ProfileName == "" {
			return fmt.Errorf("profile name is required")
		}
		if data.Domain == "" {
			return fmt.Errorf("domain is required")
		}
	case WizardStepCloudflare:
		if data.APIToken == "" {
			return fmt.Errorf("API token is required")
		}
		if data.ZoneID == "" {
			return fmt.Errorf("Zone ID is required")
		}
	case WizardStepDockerConfig:
		if data.CaddyfilePath == "" {
			return fmt.Errorf("Caddyfile path is required")
		}
		// Container name only required for Docker deployments
		if data.DeploymentMethod == config.DeploymentDocker && data.ContainerName == "" {
			return fmt.Errorf("container name is required for Docker deployment")
		}
		// Caddy binary path required for system deployments
		if data.DeploymentMethod == config.DeploymentSystem && data.CaddyBinaryPath == "" {
			return fmt.Errorf("caddy binary path is required")
		}
	}
	return nil
}

// ValidateProfile performs comprehensive validation before saving a new profile
func ValidateProfile(data *WizardData) error {
	// 1. Check profile name uniqueness
	profiles, err := config.ListProfiles()
	if err != nil {
		return fmt.Errorf("failed to check existing profiles: %w", err)
	}

	for _, existingProfile := range profiles {
		if existingProfile == data.ProfileName {
			return fmt.Errorf("profile '%s' already exists - please choose a different name", data.ProfileName)
		}
	}

	// 2. Check domain uniqueness across all profiles
	for _, profileName := range profiles {
		existingConfig, err := config.LoadProfile(profileName)
		if err != nil {
			continue
		}

		if existingConfig.Domain == data.Domain {
			return fmt.Errorf("domain '%s' is already managed by profile '%s' - managing the same domain in multiple profiles will cause conflicts", data.Domain, profileName)
		}
	}

	// 3. Validate Caddyfile path
	if data.CaddyfilePath == "" {
		return fmt.Errorf("Caddyfile path cannot be empty")
	}

	// Check if file exists
	if _, err := os.Stat(data.CaddyfilePath); err != nil {
		if os.IsNotExist(err) {
			parentDir := filepath.Dir(data.CaddyfilePath)
			if _, err := os.Stat(parentDir); err != nil {
				return fmt.Errorf("Caddyfile parent directory does not exist: %s", parentDir)
			}
		} else {
			return fmt.Errorf("cannot access Caddyfile path: %w", err)
		}
	}

	// 4. Validate deployment-specific fields
	if data.DeploymentMethod == config.DeploymentDocker {
		if data.ContainerName == "" {
			return fmt.Errorf("container name cannot be empty for Docker deployment")
		}
	} else if data.DeploymentMethod == config.DeploymentSystem {
		if data.CaddyBinaryPath == "" {
			return fmt.Errorf("caddy binary path cannot be empty for system deployment")
		}
		// Verify caddy binary exists
		if _, err := os.Stat(data.CaddyBinaryPath); err != nil {
			return fmt.Errorf("caddy binary not found at %s", data.CaddyBinaryPath)
		}
	}

	return nil
}
